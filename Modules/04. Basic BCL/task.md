# Задание "Базовая библиотека типов"

## Введение
Заказчик «Библиотечная сеть» предлагает разработать приложение для каталогизации информации о хранимых в библиотеке объектах (книги, журналы, газеты и т.д.). Приложение должно реализовывать следующий функционал:
1.	Добавление записей в каталог
2.	Удаление записей из каталога
3.	Просмотр каталога
4.	Поиск по названию
5.	Сортировка по году выпуска в прямом и обратном порядке
6.	Поиск всех книг данного автора (в том числе, тех, у которых он является соавтором)
7.	Вывод всех книг, название издательства которых начинаются с заданного набора символов, с группировкой по издательству
8.	Группировка записей по годам издания


## Описание хранимых объектов
### Книги
|Поле|Ограничения|
|--|--|
|Название|Не может быть пустым|
|Автор(ы)|Не может быть пустым| 
|Место издания (город)|Не может быть пустым|
|Название издательства|Не может быть пустым|
|Год издания|У нас нет изданий до 1900 года|
|Количество страниц||
|Примечание||
|Международный стандартный номер книги (ISBN)||

### Газеты
|Поле|Ограничения|
|--|--|
|Название|Не может быть пустым|
|Место издания (город)||
|Название издательства|Не может быть пустым|
|Год издания|У нас нет изданий до 1900 года|
|Количество страниц||
|Примечание||
|Номер|Положительный|
|Дата||
|Международный стандартный номер серийного издания (ISSN)||

### Патенты
|Поле|Ограничения|
|--|--|
|Название|Не может быть пустым|
|Изобретатель(и)|Не может быть пустым|
|Страна|Не может быть пустым|
|Регистрационный номер||
|Дата подачи заявки|Не ранее 1950 года|
|Дата публикации|Не ранее 1950 года|
|Количество страниц||
|Примечание||

## Задание 1. Модель предметной области, сервисы, тесты и интерфейс DAL
Здесь нужно реализовать модель нашей предметной области, и слой сервисов, но пока без реализации доступа к данным.

При разработке модели предметной области не забывайте, что мы проектируем не реляционную модель, а модель объектов в памяти, поэтому подходы могут различаться.

Предлагаю (но не настаиваю) воспользоваться следующим подходом:

### Шаг 1. Модель и интерфесы сервисов
На основе приведенной постановки, разработайте модель предметной области, а также **интерфейс** сервиса(ов) который позволяет решить перечисленные задачи.

Подумайте над тем:
- какие сущности, помимо явно укзаанных, стоит еще выделить
- какой тип взять за основу сущностей: class, struct, record, ...
- если между сущностями нужно указать связи, то будут ли они в одну сторону или двухсторонними


## Шаг 2. Реализация сервисов, тесты, и интерфейсы слоя данных
Используя подход "Разработка через тесты" (TDD) (не совсем в чистом виде, но тем не менее), реализуйте сами сераисы.

В чем идея подхода:
- **Берем какой-то аспект сервиса.** Например, "Метод GetAll() у сервиса BooskService возвращает все записи в произвольном порядке"
- **Пишем на этот метод тест**. В нашем случае, примерно так:
    - заводим набор тестовых книг
    - вызываем метод GetAll()
    - сравниваем, что он сосвпал с тестовым набором

    *(Очевидно, что тест сейчас упадет - у нас нет реализации)* 
- **Делаем реализацию.** Пусть она просто получает у слоя данных все книги как есть и возвращает.
    - Тут нам потребовался некий DAL - сделаем его в виде набора интерфесов репозиториев. Здесь конкретно IBookRepository с единсвенным методом GetAll()
    - Использум в сервисе этот интерфейс (в нашем случае можно просто сразу вернуть, то что вернул репозиторий). Не забываем про подход DI(!) - интерфейс репозитория передаем в сервис через конструктор
- **Дорабатываем тест**. В сервис в тесте передаем или репозиторий-заглушку (stub), или репозиторий-мок, в которых реализован только 1 метод GetAll, который просто возвращает нашу тестовую коллекцию.
- **Запускаем тест, смотрим, что он прошел!!!**

Ну а делее повторяем для всех аспектов нашей библиотеки

Важные моменты:
- предлагаю наш слой DAL оставить максимально простым: он умеет читать и писать сущноасти, но все навороты:
    - поиск
    - сортировка
    - группировка
    - ...

делаются уже в памяти, нашим слоем сервисов

- при операциях изменения (записи новой сущности) запускать валидацию и не давать сохранить невалидные сущности (но возможность запустить валидацию отдельно - тоже оставить)
- под группировкой будем пока просто понимать такую сортировку, чтобы сгруппированные сущности шли рядом

## Задание 2. Реализация DAL и тесты
Теперь реализуем DAL (у нас уже есть интерфейсы репозиториев).

Для хранения используем текстовый(е) файл(ы):
- формат хранения определите и опишите самостоятельно. Наложено только одно ограничение, что каждый объект храниться в одной строке файла
- сохранение изменений можно делать переписываением всего файла(ов) данных (тут на ваше усмотрение - если проще сделать замену отдельных записей, делайте так)

Подумайте над следующими моментами:
- будут ли у вас чисто справочные сущности (т.е. которые ваша библиотека не правит, а только читает)? Будут ли чем-то отличать их файлы (если у вас их несколько) и работа с их файлами?
- возможно (но не обязательно!) можно иметь общее хранилище всех сущностей в памяти, которое работает примерно так: 
    - загружаются разом все сущности в память и создаются нужные связи
    - репозиории отдают объекты (или их копии...) из этого хранилища
    - по запросу можно сохранить текущее состояние на диск (опять же не заморачиваем отслеживанием - что реально менялось).

Обязательно напишите тесты на ваш DAL! Здесь оставляю выбор за вами:
- либо мы пишем полноценные интеграционные тесты:
    - т.е. создаем реальную структуру файлов на диске
    - читаем и изменяем её
    - в тестах проверяем изменения в этих файлах

- либо работаем не напрямую с классами из System.IO, а используем прослойку типа https://github.com/TestableIO/System.IO.Abstractions - это реализация тех же операций, но с возможностью сделать Moq-и для работы с файлами.